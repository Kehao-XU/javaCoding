# Lesson2 拓展练习题

## 练习题1：对象引用与基本类型传递的深入理解

### 背景
在WalrusLauncher中，你已经学习了对象引用传递和基本类型值传递的区别。现在我们创建一个更复杂的场景来加深理解。

### 任务描述
创建一个`Student`类和一个`StudentManager`类，实现以下功能：

#### Student类要求：
1. 包含属性：`name`（String类型）、`score`（int类型）、`grade`（char类型）
2. 包含构造函数，可以初始化所有属性
3. 包含方法：
   - `upgradeScore(int points)`：增加分数，但不能超过100
   - `downgradeScore(int points)`：减少分数，但不能低于0
   - `calculateGrade()`：根据分数计算等级（90-100为A，80-89为B，70-79为C，60-69为D，0-59为F）
   - `printStudent()`：打印学生信息

#### StudentManager类要求：
1. 包含静态方法：
   - `adjustStudentScore(Student s, int adjustment)`：调整学生分数
   - `batchAdjust(Student[] students, int adjustment)`：批量调整多个学生的分数
   - `findTopStudent(Student[] students)`：找出分数最高的学生
   - `calculateAverage(Student[] students)`：计算所有学生的平均分

2. 在main方法中：
   - 创建3-5个Student对象
   - 演示单个学生分数调整
   - 演示批量调整
   - 找出最高分学生并显示
   - 计算并显示平均分

### 思考问题
1. 当你将Student对象传递给方法时，方法内部修改分数会影响原始对象吗？
2. 当你传递一个int类型的分数值给方法时，方法内部修改会影响原始值吗？
3. 如果在`adjustStudentScore`方法中创建一个新的Student对象，会影响传入的原始对象吗？

### 提示
- 参考Walrus和WalrusLauncher的代码结构
- 注意对象引用传递和基本类型值传递的区别
- 使用循环来处理数组中的多个对象

---

## 练习题2：链表操作的进阶应用

### 背景
在IntList和IncrList中，你已经学习了链表的基本操作和递归方法。现在我们创建一个更实用的链表应用。

### 任务描述
创建一个`NumberList`类，实现一个数字链表，包含以下功能：

#### NumberList类要求：
1. 包含属性：`value`（int类型）、`next`（NumberList类型）
2. 包含构造函数，可以初始化value和next
3. 包含递归方法：
   - `sum()`：计算链表中所有数字的总和
   - `max()`：找出链表中的最大值
   - `min()`：找出链表中的最小值
   - `contains(int target)`：检查链表中是否包含某个值
   - `reverse()`：反转链表（返回新的反转后的链表）

4. 包含迭代方法：
   - `iterativeSum()`：使用迭代方式计算总和
   - `iterativeMax()`：使用迭代方式找出最大值
   - `iterativeContains(int target)`：使用迭代方式检查是否包含某个值

5. 包含工具方法：
   - `printList()`：打印链表中的所有值
   - `append(int newValue)`：在链表末尾添加新值
   - `remove(int target)`：删除链表中第一个出现的指定值

6. 包含静态方法：
   - `createList(int[] values)`：根据数组创建链表
   - `mergeSortedLists(NumberList list1, NumberList list2)`：合并两个已排序的链表（假设输入链表已排序）

### 在main方法中演示：
1. 创建一个包含多个数字的链表
2. 测试所有递归方法（sum, max, min, contains, reverse）
3. 测试所有迭代方法（iterativeSum, iterativeMax, iterativeContains）
4. 测试工具方法（append, remove）
5. 创建两个已排序的链表，演示合并功能

### 思考问题
1. 递归方法和迭代方法在实现上有什么不同？
2. 哪些方法更适合用递归实现？哪些更适合用迭代实现？
3. 反转链表时，为什么需要创建新的链表而不是直接修改原链表？
4. 在合并已排序链表时，如何保证结果链表也是有序的？

### 提示
- 参考IntList和IncrList的递归实现方式
- 注意递归的终止条件
- 在迭代方法中使用while循环遍历链表
- 合并已排序链表时，比较两个链表的当前节点值，选择较小的先加入结果链表

---

## 评分标准

### 练习题1（50分）
- Student类实现正确（15分）
- StudentManager类静态方法实现正确（20分）
- main方法演示完整（10分）
- 思考问题回答准确（5分）

### 练习题2（50分）
- NumberList类基本结构正确（10分）
- 递归方法实现正确（15分）
- 迭代方法实现正确（10分）
- 工具方法实现正确（10分）
- 思考问题回答准确（5分）

## 提交要求
1. 将两个练习的Java文件放在Lesson2目录下
2. 文件名分别为：`StudentManager.java` 和 `NumberList.java`
3. 确保代码可以正常编译和运行
4. 在代码中添加必要的注释说明关键逻辑